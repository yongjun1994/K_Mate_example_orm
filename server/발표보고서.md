# K-Mate 백엔드 시스템 발표 보고서

## 📋 프로젝트 개요

### 프로젝트명
**K-Mate** - 한국 여행 정보 공유 플랫폼

### 프로젝트 목적
한국을 방문하는 외국인 관광객과 한국 여행에 관심 있는 사용자들을 위한 종합적인 여행 정보 공유 플랫폼을 구축하여, 실시간 여행 정보, 장소 추천, 커뮤니티 기능을 제공하는 것이 목표입니다.

### 배경
- 한국 관광산업의 성장과 K-컬처 확산
- 외국인 관광객 증가에 따른 실용적인 여행 정보 수요 증가
- 기존 여행 정보 플랫폼의 한계점 보완 필요성
- 사용자 중심의 커뮤니티 기반 정보 공유 시스템 구축 필요

## 🛠️ 기술 스택

### 백엔드 프레임워크
- **NestJS 11.1.6**: Node.js 기반의 확장 가능한 서버 사이드 애플리케이션 프레임워크
- **TypeScript**: 정적 타입 검사를 통한 안정적인 코드 작성

### 데이터베이스
- **MySQL 8.0**: 관계형 데이터베이스 관리 시스템
- **TypeORM 0.3.20**: TypeScript/JavaScript용 ORM

### 인증 및 보안
- **JWT (JSON Web Token)**: 사용자 인증 및 세션 관리
- **Google OAuth 2.0**: 소셜 로그인 인증
- **Passport.js**: 인증 미들웨어
- **bcrypt**: 비밀번호 해싱

### API 문서화
- **Swagger/OpenAPI**: 자동 API 문서 생성

### 테스트
- **Jest**: 테스트 프레임워크
- **Supertest**: HTTP 테스트
- **@nestjs/testing**: NestJS 테스트 유틸리티

### 개발 도구
- **ESLint**: 코드 품질 관리
- **Prettier**: 코드 포맷팅
- **class-validator**: DTO 검증
- **class-transformer**: 객체 변환

## 🏗️ 시스템 아키텍처

### 모듈 구조
```
src/
├── app.module.ts              # 루트 모듈
├── config/                    # 설정 관리
├── database/                  # 데이터베이스 모듈
├── common/                    # 공통 유틸리티
│   ├── decorators/           # 커스텀 데코레이터
│   ├── guards/               # 인증/인가 가드
│   ├── filters/              # 예외 필터
│   └── exceptions/           # 커스텀 예외
└── features/                  # 기능별 모듈
    ├── auth/                 # 인증
    ├── users/                # 사용자 관리
    ├── places/               # 장소 관리
    ├── posts/                # 게시글 관리
    ├── comments/             # 댓글 관리
    ├── interactions/         # 상호작용 (좋아요/싫어요)
    └── bookmarks/            # 북마크
```

### 데이터베이스 ERD
```
Users (사용자)
├── id (PK)
├── google_sub (UK)
├── email, name, avatar_url
├── email_verified, role
└── created_at, updated_at

Posts (게시글)
├── id (PK)
├── title, content, image_url
├── view_count, like_count, comment_count
├── category (buzz/review/question)
├── author_id (FK → Users)
├── place_id (FK → Places, nullable)
└── created_at, updated_at

Places (장소)
├── id (PK)
├── name, description, address
├── latitude, longitude
├── image_url, category
└── created_at, updated_at

Comments (댓글)
├── id (PK)
├── content
├── author_id (FK → Users)
├── post_id (FK → Posts)
└── created_at, updated_at

Interactions (상호작용)
├── id (PK)
├── type (like/dislike)
├── user_id (FK → Users)
├── post_id (FK → Posts)
└── created_at

Bookmarks (북마크)
├── id (PK)
├── user_id (FK → Users)
├── post_id (FK → Posts)
└── created_at
```

## 🔧 ORM (Object-Relational Mapping) 상세 분석

### ORM 개념과 원리

**ORM(Object-Relational Mapping)**은 객체 지향 프로그래밍 언어와 관계형 데이터베이스 간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법입니다.

#### ORM의 핵심 원리
1. **객체-관계 매핑**: 클래스와 테이블을 1:1로 매핑
2. **자동 SQL 생성**: 메서드 호출을 SQL 쿼리로 자동 변환
3. **데이터 타입 변환**: 프로그래밍 언어 타입과 DB 타입 간 자동 변환
4. **관계 매핑**: 객체 간 관계를 외래키로 자동 처리

### ORM 사용 목적

1. **개발 생산성 향상**
   - SQL 작성 없이 객체 조작으로 DB 작업
   - 타입 안정성으로 런타임 오류 감소

2. **데이터베이스 독립성**
   - DB 벤더에 관계없이 동일한 코드 사용
   - 마이그레이션 시 코드 변경 최소화

3. **유지보수성**
   - 비즈니스 로직과 데이터 접근 로직 분리
   - 코드의 가독성과 재사용성 향상

4. **보안성**
   - SQL 인젝션 공격 방지
   - 자동 이스케이프 처리

### ORM 종류 비교

| ORM | 언어 | 특징 | 장점 | 단점 |
|-----|------|------|------|------|
| **TypeORM** | TypeScript/JS | 데코레이터 기반, Active Record 패턴 | 타입 안정성, 직관적 문법 | 복잡한 쿼리 제한 |
| **Sequelize** | JavaScript | Promise 기반, 다양한 DB 지원 | 성숙한 생태계 | 타입 지원 부족 |
| **Prisma** | TypeScript | 스키마 우선, 타입 안전 | 강력한 타입 시스템 | 런타임 오버헤드 |
| **Mongoose** | JavaScript | MongoDB 전용 | NoSQL 최적화 | 관계형 DB 미지원 |

### K-Mate 프로젝트에서의 TypeORM 사용

#### 1. 엔티티 정의 (Entity Definition)
```typescript
@Entity('users')
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ unique: true })
  google_sub: string;

  @Column({ type: 'enum', enum: ['user', 'admin'], default: 'user' })
  role: 'user' | 'admin';

  @OneToMany(() => Post, post => post.author)
  posts: Post[];

  @CreateDateColumn()
  created_at: Date;
}
```

#### 2. 관계 매핑 (Relationship Mapping)
```typescript
// One-to-Many 관계
@OneToMany(() => Post, post => post.author)
posts: Post[];

// Many-to-One 관계
@ManyToOne(() => User, user => user.posts)
@JoinColumn({ name: 'author_id' })
author: User;
```

#### 3. 데이터베이스 설정
```typescript
TypeOrmModule.forRootAsync({
  useFactory: (configService: ConfigService) => ({
    type: 'mysql',
    host: configService.get('database.host'),
    port: configService.get('database.port'),
    username: configService.get('database.user'),
    password: configService.get('database.password'),
    database: configService.get('database.database'),
    entities: [User, Post, Comment, Interaction, Place, Bookmark],
    synchronize: configService.get('app.nodeEnv') === 'development',
    logging: configService.get('app.nodeEnv') === 'development',
  }),
})
```

#### 4. Repository 패턴 활용
```typescript
@Injectable()
export class PostsService {
  constructor(
    @InjectRepository(Post)
    private postsRepository: Repository<Post>,
  ) {}

  async findAll(page: number, limit: number): Promise<Post[]> {
    return this.postsRepository.find({
      skip: (page - 1) * limit,
      take: limit,
      relations: ['author', 'place'],
    });
  }
}
```

### TypeORM 사용 경험 및 결론

#### 장점
1. **타입 안정성**: TypeScript와 완벽한 통합으로 컴파일 타임 오류 검출
2. **직관적인 문법**: 데코레이터를 통한 선언적 엔티티 정의
3. **자동 마이그레이션**: `synchronize` 옵션으로 개발 환경에서 자동 스키마 동기화
4. **관계 매핑**: 복잡한 관계를 간단한 데코레이터로 표현
5. **쿼리 빌더**: 복잡한 쿼리도 타입 안전하게 작성 가능

#### 단점
1. **성능 오버헤드**: N+1 쿼리 문제 발생 가능성
2. **복잡한 쿼리 제한**: 매우 복잡한 SQL은 직접 작성 필요
3. **학습 곡선**: 데코레이터 문법과 관계 매핑 개념 이해 필요
4. **메모리 사용량**: 대용량 데이터 처리 시 메모리 효율성 문제

#### 개선 방안
1. **Eager/Lazy Loading 최적화**: 필요한 관계만 로드
2. **쿼리 최적화**: `select`와 `relations` 옵션 적절히 활용
3. **인덱스 설계**: 자주 조회되는 컬럼에 인덱스 추가
4. **캐싱 전략**: Redis 등을 활용한 쿼리 결과 캐싱

## 🚀 API 설계 및 구현

### RESTful API 설계 원칙
- **리소스 기반 URL**: `/posts`, `/users`, `/places`
- **HTTP 메서드 활용**: GET, POST, PATCH, DELETE
- **상태 코드**: 200, 201, 400, 401, 404, 500
- **일관된 응답 형식**: JSON 형태의 표준화된 응답

### 주요 API 엔드포인트

#### 인증 API
```
GET  /auth/google              # Google OAuth 시작
GET  /auth/google/callback     # OAuth 콜백 처리
POST /auth/refresh             # 토큰 갱신
POST /auth/validate            # 토큰 검증
```

#### 사용자 API
```
GET  /users                    # 사용자 목록 (관리자)
GET  /users/profile            # 현재 사용자 프로필
GET  /users/:id                # 특정 사용자 정보
PUT  /users/profile            # 프로필 수정
DELETE /users/:id              # 사용자 삭제 (관리자)
```

#### 게시글 API
```
GET  /posts                    # 게시글 목록 (페이지네이션, 필터링)
GET  /posts/popular            # 인기 게시글
GET  /posts/recent             # 최신 게시글
GET  /posts/my-posts           # 내 게시글
GET  /posts/:id                # 특정 게시글
POST /posts                    # 게시글 작성
PATCH /posts/:id               # 게시글 수정
DELETE /posts/:id              # 게시글 삭제
```

#### 장소 API
```
GET  /places                   # 장소 목록
GET  /places/popular           # 인기 장소
GET  /places/category/:category # 카테고리별 장소
GET  /places/nearby            # 근처 장소 (위치 기반)
GET  /places/:id               # 특정 장소
POST /places                   # 장소 추가 (관리자)
PATCH /places/:id              # 장소 수정 (관리자)
DELETE /places/:id             # 장소 삭제 (관리자)
```

### 인증 및 인가 시스템

#### JWT 토큰 구조
```typescript
interface JWTPayload {
  userId: number;
  email: string;
  role: 'user' | 'admin';
  iat: number;
  exp: number;
}
```

#### 가드 시스템
```typescript
@UseGuards(JwtAuthGuard)           # JWT 인증
@UseGuards(JwtAuthGuard, RolesGuard) # JWT + 역할 기반 인가
@Roles('admin')                    # 관리자 권한
```

## 🧪 테스트 전략

### 테스트 피라미드
```
    /\
   /  \     E2E Tests (5%)
  /____\    - 전체 사용자 시나리오
 /      \   
/________\  Integration Tests (15%)
           - API 엔드포인트 테스트
           - 데이터베이스 연동 테스트

Unit Tests (80%)
- 서비스 로직 테스트
- 컨트롤러 테스트
- 유틸리티 함수 테스트
```

### 테스트 커버리지 현황
- **전체 커버리지**: 36.21%
- **Posts Service**: 97.72%
- **Comments Service**: 94.59%
- **Users Service**: 100%
- **Posts Controller**: 100%

### 테스트 실행 명령어
```bash
# 모든 테스트
npm run test:all

# 단위 테스트
npm run test:unit

# 통합 테스트
npm run test:integration

# E2E 테스트
npm run test:e2e

# 커버리지 확인
npm run test:cov
```

## 📦 설치 및 실행

### 환경 요구사항
- Node.js 18.x 이상
- MySQL 8.0 이상
- npm 또는 yarn

### 설치 명령어
```bash
# 프로젝트 클론
git clone <repository-url>
cd workspace/server

# 의존성 설치
npm install

# 환경 변수 설정
cp .env.example .env
# .env 파일 편집

# 데이터베이스 설정
mysql -u root -p
CREATE DATABASE k_mate_db;

# 애플리케이션 실행
npm run start:dev
```

### 환경 변수 설정
```env
# 애플리케이션 설정
APP_PORT=3000
NODE_ENV=development
FRONTEND_URL=http://localhost:5173

# 데이터베이스 설정
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_PASS=password
DB_NAME=k_mate_db

# JWT 설정
JWT_SECRET=your-super-secret-jwt-key
JWT_EXPIRES_IN=3600s
JWT_REFRESH_SECRET=your-refresh-secret
JWT_REFRESH_EXPIRES_IN=7d

# Google OAuth 설정
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret
GOOGLE_CALLBACK_URL=http://localhost:3000/auth/google/callback
```

## 🎯 프로젝트 특장점

### 1. 확장 가능한 아키텍처
- **모듈화된 구조**: 기능별 독립적인 모듈 설계
- **의존성 주입**: NestJS의 DI 컨테이너 활용
- **설정 관리**: 환경별 설정 분리

### 2. 보안성
- **JWT 기반 인증**: 상태 없는 인증 시스템
- **역할 기반 접근 제어**: 사용자/관리자 권한 분리
- **입력 검증**: class-validator를 통한 DTO 검증

### 3. 개발자 경험
- **타입 안정성**: TypeScript로 런타임 오류 최소화
- **자동 문서화**: Swagger를 통한 API 문서 자동 생성
- **테스트 자동화**: Jest 기반 포괄적 테스트

### 4. 성능 최적화
- **페이지네이션**: 대용량 데이터 효율적 처리
- **관계 로딩**: 필요한 데이터만 선택적 로드
- **인덱스 설계**: 자주 조회되는 컬럼 최적화

## 📊 장단점 분석

### 장점
1. **개발 생산성**: TypeORM과 NestJS로 빠른 개발
2. **코드 품질**: TypeScript와 테스트로 안정성 확보
3. **유지보수성**: 모듈화된 구조로 쉬운 수정
4. **확장성**: 마이크로서비스로 확장 가능
5. **문서화**: 자동 생성되는 API 문서

### 단점
1. **학습 곡선**: NestJS와 TypeORM 학습 필요
2. **성능 오버헤드**: ORM의 추가적인 처리 비용
3. **복잡성**: 대규모 프로젝트에서 복잡도 증가
4. **의존성**: 많은 외부 라이브러리 의존

## 🔮 향후 개선 계획

### 단기 계획
1. **테스트 커버리지 향상**: 80% 이상 달성
2. **API 성능 최적화**: 쿼리 최적화 및 캐싱
3. **에러 처리 개선**: 표준화된 에러 응답
4. **로깅 시스템**: 구조화된 로그 관리

### 중기 계획
1. **마이크로서비스 전환**: 도메인별 서비스 분리
2. **실시간 기능**: WebSocket을 통한 실시간 알림
3. **파일 업로드**: 이미지/동영상 업로드 기능
4. **검색 엔진**: Elasticsearch 통합

### 장기 계획
1. **AI 추천 시스템**: 머신러닝 기반 개인화
2. **다국어 지원**: i18n 국제화
3. **모바일 API**: React Native 지원
4. **클라우드 배포**: AWS/Azure 배포

## 📈 결론

K-Mate 백엔드 시스템은 현대적인 웹 개발 기술 스택을 활용하여 확장 가능하고 안정적인 API 서버를 구축했습니다. TypeORM을 통한 ORM 활용으로 개발 생산성을 크게 향상시켰으며, NestJS의 모듈화된 아키텍처로 유지보수성을 확보했습니다.

특히 TypeORM의 타입 안정성과 직관적인 문법은 복잡한 데이터베이스 관계를 효율적으로 관리할 수 있게 해주었으며, 자동 마이그레이션 기능으로 개발 환경에서의 스키마 관리가 매우 편리했습니다.

앞으로 지속적인 테스트 커버리지 향상과 성능 최적화를 통해 더욱 안정적이고 효율적인 시스템으로 발전시켜 나갈 계획입니다.
