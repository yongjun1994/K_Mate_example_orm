# K-Mate 백엔드 시스템 발표 대본

## 🎤 발표 시작 (1분)

안녕하세요. 저는 K-Mate 프로젝트의 백엔드 개발을 담당한 [이름]입니다.

오늘은 **NestJS와 TypeORM을 활용한 한국 여행 정보 공유 플랫폼**의 백엔드 시스템에 대해 발표하겠습니다.

발표 순서는 다음과 같습니다:
1. 프로젝트 개요 및 목적
2. 기술 스택 선택 이유
3. ORM 상세 분석 및 활용
4. 시스템 아키텍처
5. API 설계 및 구현
6. 테스트 전략
7. 프로젝트 성과 및 결론

---

## 📋 1. 프로젝트 개요 및 목적 (2분)

### 프로젝트 소개
K-Mate는 **한국을 방문하는 외국인 관광객과 한국 여행에 관심 있는 사용자들을 위한 종합적인 여행 정보 공유 플랫폼**입니다.

### 개발 배경
- 한국 관광산업의 성장과 K-컬처 확산으로 외국인 관광객이 급증하고 있습니다
- 기존 여행 정보 플랫폼들은 실시간 정보 부족과 사용자 참여도가 낮은 문제가 있었습니다
- 이를 해결하기 위해 **커뮤니티 기반의 실시간 여행 정보 공유 시스템**을 구축했습니다

### 주요 기능
- **Google OAuth 2.0 기반 소셜 로그인**
- **장소 정보 관리** (맛집, 카페, 관광지 등)
- **커뮤니티 게시글** (버즈, 리뷰, 질문)
- **댓글 및 상호작용** (좋아요/싫어요, 북마크)
- **위치 기반 장소 검색**

---

## 🛠️ 2. 기술 스택 선택 이유 (3분)

### 백엔드 프레임워크: NestJS
**왜 NestJS를 선택했나요?**

1. **TypeScript 네이티브 지원**
   - 컴파일 타임 오류 검출로 안정성 확보
   - IDE 지원으로 개발 생산성 향상

2. **모듈화된 아키텍처**
   - 기능별 독립적인 모듈 설계
   - 확장성과 유지보수성 확보

3. **의존성 주입 (DI)**
   - 테스트 용이성
   - 느슨한 결합으로 코드 재사용성 향상

4. **풍부한 생태계**
   - 다양한 데코레이터와 가드 제공
   - Swagger 자동 문서화 지원

### 데이터베이스: MySQL + TypeORM
**MySQL 선택 이유:**
- 안정성과 성숙도가 검증된 RDBMS
- 복잡한 관계형 데이터 처리에 최적화
- 대용량 데이터 처리 능력

**TypeORM 선택 이유:**
- TypeScript와 완벽한 통합
- 데코레이터 기반의 직관적인 문법
- 자동 마이그레이션 지원

---

## 🔧 3. ORM 상세 분석 및 활용 (5분)

### ORM이란?
**Object-Relational Mapping**은 객체 지향 프로그래밍과 관계형 데이터베이스 간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법입니다.

### ORM의 핵심 원리
1. **객체-관계 매핑**: 클래스와 테이블을 1:1로 매핑
2. **자동 SQL 생성**: 메서드 호출을 SQL 쿼리로 자동 변환
3. **데이터 타입 변환**: 프로그래밍 언어 타입과 DB 타입 간 자동 변환

### ORM 사용 목적
- **개발 생산성 향상**: SQL 작성 없이 객체 조작으로 DB 작업
- **데이터베이스 독립성**: DB 벤더에 관계없이 동일한 코드 사용
- **보안성**: SQL 인젝션 공격 방지

### TypeORM vs 다른 ORM 비교

| 특징 | TypeORM | Sequelize | Prisma |
|------|---------|-----------|--------|
| 타입 안정성 | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| 학습 곡선 | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| 성능 | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 생태계 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |

### K-Mate에서의 TypeORM 활용

#### 1. 엔티티 정의
```typescript
@Entity('users')
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ unique: true })
  google_sub: string;

  @Column({ type: 'enum', enum: ['user', 'admin'], default: 'user' })
  role: 'user' | 'admin';

  @OneToMany(() => Post, post => post.author)
  posts: Post[];
}
```

#### 2. 관계 매핑
- **One-to-Many**: User → Posts (한 사용자가 여러 게시글 작성)
- **Many-to-One**: Post → User (게시글은 한 사용자에 속함)
- **Many-to-Many**: User ↔ Posts (북마크 관계)

#### 3. 쿼리 최적화
```typescript
// 필요한 관계만 로드
const posts = await this.postsRepository.find({
  relations: ['author', 'place'],
  where: { is_active: true }
});
```

### TypeORM 사용 경험

#### 장점
1. **타입 안정성**: 컴파일 타임에 오류 검출
2. **직관적인 문법**: 데코레이터로 간단한 엔티티 정의
3. **자동 마이그레이션**: 개발 환경에서 스키마 자동 동기화
4. **관계 매핑**: 복잡한 관계를 간단하게 표현

#### 단점
1. **성능 오버헤드**: N+1 쿼리 문제 발생 가능
2. **복잡한 쿼리 제한**: 매우 복잡한 SQL은 직접 작성 필요
3. **학습 곡선**: 데코레이터 문법 이해 필요

#### 개선 방안
- **Eager/Lazy Loading 최적화**
- **쿼리 빌더 활용**
- **인덱스 설계**

---

## 🏗️ 4. 시스템 아키텍처 (3분)

### 모듈 구조
```
src/
├── app.module.ts              # 루트 모듈
├── config/                    # 설정 관리
├── database/                  # 데이터베이스 모듈
├── common/                    # 공통 유틸리티
└── features/                  # 기능별 모듈
    ├── auth/                 # 인증
    ├── users/                # 사용자 관리
    ├── places/               # 장소 관리
    ├── posts/                # 게시글 관리
    ├── comments/             # 댓글 관리
    ├── interactions/         # 상호작용
    └── bookmarks/            # 북마크
```

### 데이터베이스 ERD
**핵심 엔티티:**
- **Users**: 사용자 정보 (Google OAuth 연동)
- **Posts**: 게시글 (버즈, 리뷰, 질문)
- **Places**: 장소 정보 (맛집, 카페, 관광지)
- **Comments**: 댓글
- **Interactions**: 좋아요/싫어요
- **Bookmarks**: 북마크

**관계:**
- User 1:N Posts (작성자)
- Post N:1 Place (관련 장소)
- Post 1:N Comments (댓글)
- User N:M Posts (북마크, 상호작용)

### 인증 시스템
- **JWT 기반**: 상태 없는 인증
- **Google OAuth 2.0**: 소셜 로그인
- **역할 기반 접근 제어**: 사용자/관리자 권한 분리

---

## 🚀 5. API 설계 및 구현 (4분)

### RESTful API 설계 원칙
- **리소스 기반 URL**: `/posts`, `/users`, `/places`
- **HTTP 메서드 활용**: GET, POST, PATCH, DELETE
- **일관된 응답 형식**: JSON 형태의 표준화된 응답

### 주요 API 엔드포인트

#### 인증 API
```
GET  /auth/google              # Google OAuth 시작
GET  /auth/google/callback     # OAuth 콜백 처리
POST /auth/refresh             # 토큰 갱신
POST /auth/validate            # 토큰 검증
```

#### 게시글 API
```
GET  /posts                    # 게시글 목록 (페이지네이션, 필터링)
GET  /posts/popular            # 인기 게시글
POST /posts                    # 게시글 작성
PATCH /posts/:id               # 게시글 수정
DELETE /posts/:id              # 게시글 삭제
```

#### 장소 API
```
GET  /places                   # 장소 목록
GET  /places/nearby            # 근처 장소 (위치 기반)
POST /places                   # 장소 추가 (관리자)
```

### 보안 구현
```typescript
@UseGuards(JwtAuthGuard)           # JWT 인증
@UseGuards(JwtAuthGuard, RolesGuard) # JWT + 역할 기반 인가
@Roles('admin')                    # 관리자 권한
```

### 입력 검증
```typescript
export class CreatePostDto {
  @IsString()
  @IsNotEmpty()
  @Length(1, 200)
  title: string;

  @IsString()
  @IsNotEmpty()
  @Length(10, 5000)
  content: string;
}
```

---

## 🧪 6. 테스트 전략 (3분)

### 테스트 피라미드
```
    /\
   /  \     E2E Tests (5%)
  /____\    - 전체 사용자 시나리오
 /      \   
/________\  Integration Tests (15%)
           - API 엔드포인트 테스트

Unit Tests (80%)
- 서비스 로직 테스트
- 컨트롤러 테스트
```

### 테스트 커버리지 현황
- **전체 커버리지**: 36.21%
- **Posts Service**: 97.72%
- **Comments Service**: 94.59%
- **Users Service**: 100%

### 테스트 실행
```bash
# 모든 테스트
npm run test:all

# 단위 테스트
npm run test:unit

# 통합 테스트
npm run test:integration

# E2E 테스트
npm run test:e2e
```

### 테스트 예시
```typescript
describe('PostsService', () => {
  it('should create a post', async () => {
    const createPostDto = {
      title: 'Test Post',
      content: 'Test content',
      category: 'buzz'
    };
    
    const result = await postsService.create(createPostDto, userId);
    
    expect(result.title).toBe(createPostDto.title);
    expect(result.author_id).toBe(userId);
  });
});
```

---

## 📊 7. 프로젝트 성과 및 결론 (2분)

### 달성한 성과
1. **확장 가능한 아키텍처**: 모듈화된 구조로 유지보수성 확보
2. **타입 안정성**: TypeScript로 런타임 오류 최소화
3. **자동 문서화**: Swagger를 통한 API 문서 자동 생성
4. **포괄적 테스트**: 단위/통합/E2E 테스트 구현

### TypeORM 사용 경험
**장점:**
- 타입 안정성으로 개발 생산성 향상
- 직관적인 문법으로 빠른 학습
- 자동 마이그레이션으로 스키마 관리 편의성

**단점:**
- 성능 오버헤드 존재
- 복잡한 쿼리 제한
- N+1 쿼리 문제 주의 필요

**결론:**
TypeORM은 **중소규모 프로젝트에서 개발 생산성과 타입 안정성을 중시할 때 매우 효과적인 선택**입니다. 특히 TypeScript 생태계와의 완벽한 통합은 개발자 경험을 크게 향상시켰습니다.

### 향후 계획
1. **테스트 커버리지 80% 이상 달성**
2. **성능 최적화**: 쿼리 최적화 및 캐싱
3. **실시간 기능**: WebSocket을 통한 실시간 알림
4. **마이크로서비스 전환**: 도메인별 서비스 분리

---

## 🎯 마무리 (1분)

K-Mate 백엔드 시스템은 **NestJS와 TypeORM을 활용하여 확장 가능하고 안정적인 API 서버**를 성공적으로 구축했습니다.

특히 **TypeORM의 타입 안정성과 직관적인 문법**은 복잡한 데이터베이스 관계를 효율적으로 관리할 수 있게 해주었으며, **자동 마이그레이션 기능**으로 개발 환경에서의 스키마 관리가 매우 편리했습니다.

앞으로 지속적인 테스트 커버리지 향상과 성능 최적화를 통해 더욱 안정적이고 효율적인 시스템으로 발전시켜 나갈 계획입니다.

**감사합니다. 질문이 있으시면 언제든지 말씀해 주세요.**

---

## 📝 발표 팁

### 발표 시 주의사항
1. **시간 관리**: 각 섹션별 시간을 엄수
2. **코드 설명**: 복잡한 코드는 간단히 설명하고 넘어가기
3. **시각적 자료**: ERD, 아키텍처 다이어그램 활용
4. **상호작용**: 청중과의 질의응답 시간 확보

### 발표 준비 체크리스트
- [ ] 발표 자료 준비 (PPT 또는 화면 공유)
- [ ] 코드 데모 준비
- [ ] API 문서 화면 준비
- [ ] 테스트 실행 화면 준비
- [ ] 예상 질문 답변 준비
