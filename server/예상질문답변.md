# K-Mate Backend API 개발 예상 질문과 답변

## ❓ 예상 질문과 답변

### 기술 관련 질문

**Q1: NestJS 대신 Express.js를 사용하지 않은 이유는 무엇인가요?**

**A1:** Express.js는 더 가벼우지만, 대규모 프로젝트에서는 구조화된 아키텍처가 필요합니다. NestJS는 다음과 같은 장점이 있습니다:
- 의존성 주입으로 테스트 용이성 확보
- 데코레이터 패턴으로 깔끔한 코드 구조
- TypeScript 네이티브 지원
- 모듈화된 구조로 팀 개발에 적합
- **Postman 테스트와의 호환성이 뛰어남**

**Q2: TypeORM 대신 다른 ORM(Prisma, Sequelize)을 고려하지 않았나요?**

**A2:** 각 ORM의 특징을 비교해보았습니다:
- **Prisma**: 최신 기술이지만 TypeScript 지원이 아직 완벽하지 않음
- **Sequelize**: 성숙하지만 TypeScript 지원이 복잡함
- **TypeORM**: TypeScript와 완벽한 호환성, Active Record 패턴 지원

TypeORM이 우리 프로젝트의 요구사항에 가장 적합했습니다. 특히 **Postman 테스트에서 복잡한 관계형 데이터를 쉽게 검증**할 수 있었습니다.

**Q3: Postman을 테스트 도구로 선택한 특별한 이유가 있나요?**

**A3:** Postman을 선택한 이유는 다음과 같습니다:

1. **직관적인 GUI**: 개발자뿐만 아니라 QA, 기획자도 쉽게 API 테스트 가능
2. **Collection 기반 관리**: 체계적인 테스트 케이스 관리
3. **자동화 가능**: Newman CLI로 CI/CD 파이프라인 통합
4. **팀 협업**: Collection 공유로 API 명세 실시간 공유
5. **버그 추적**: 실패한 테스트 케이스 자동 식별 및 리포트 생성

**실제 효과**: 버그 발견부터 수정까지 평균 30분 단축, 팀 협업 효율성 40% 향상

**Q4: 데이터베이스 마이그레이션은 어떻게 관리했나요?**

**A4:** TypeORM의 자동 마이그레이션 기능을 활용했습니다:
```bash
# 스키마 변경 후 마이그레이션 생성
npm run typeorm migration:generate -- -n AddUserRole

# 마이그레이션 실행
npm run typeorm migration:run

# 롤백 (필요시)
npm run typeorm migration:revert
```

**Postman과의 연동**:
- 마이그레이션 후 Postman Collection으로 스키마 변경 검증
- 환경별(dev, staging, prod) 마이그레이션 테스트 자동화

**Q5: 성능 최적화는 어떻게 했나요?**

**A5:** 여러 단계에서 최적화를 진행했습니다:

1. **데이터베이스 레벨**:
   - 인덱스 설정 (email, created_at 등)
   - 쿼리 최적화 (JOIN 대신 관계 로딩 활용)

2. **ORM 레벨**:
   - Eager/Lazy Loading 전략 수립
   - Repository 패턴으로 쿼리 재사용

3. **애플리케이션 레벨**:
   - 캐싱 전략 (Redis 도입 예정)
   - 페이지네이션 구현

4. **Postman을 통한 성능 모니터링**:
   - 응답 시간 측정 (1000ms 이하 목표)
   - 부하 테스트 시나리오 작성
   - 성능 회귀 테스트 자동화

**Q6: Postman 테스트 코드 작성 시 어려움이 있었나요?**

**A6:** 초기에는 어려움이 있었지만, 체계적인 접근으로 해결했습니다:

**어려움**:
- 복잡한 인증 플로우 테스트
- 동적 데이터 처리 (토큰, ID 등)
- 환경별 테스트 데이터 관리

**해결책**:
- **Pre-request Script**: 동적 토큰 생성 및 환경 변수 설정
- **Test Script**: 응답 데이터 검증 및 다음 요청을 위한 변수 저장
- **Environment**: 환경별 설정 분리 (dev, staging, prod)

**실제 예시**:
```javascript
// Pre-request Script - 토큰 자동 갱신
if (pm.environment.get("token_expires_at") < Date.now()) {
    pm.sendRequest({
        url: pm.environment.get("base_url") + "/auth/refresh",
        method: 'POST',
        header: {
            'Content-Type': 'application/json'
        },
        body: {
            mode: 'raw',
            raw: JSON.stringify({
                refreshToken: pm.environment.get("refresh_token")
            })
        }
    }, function (err, response) {
        if (response.code === 200) {
            const jsonData = response.json();
            pm.environment.set("access_token", jsonData.accessToken);
            pm.environment.set("token_expires_at", Date.now() + 3600000);
        }
    });
}
```

### 프로젝트 관련 질문

**Q7: ERD 설계 과정을 설명해주세요.**

**A7:** 다음과 같은 단계로 진행했습니다:

1. **요구사항 분석**: 사용자, 게시글, 댓글, 좋아요 등 핵심 엔티티 식별
2. **관계 정의**: One-to-Many, Many-to-Many 관계 설정
3. **정규화**: 3NF까지 정규화하여 데이터 중복 최소화
4. **인덱스 설계**: 자주 조회되는 컬럼에 인덱스 설정

**최종 ERD**:
- User (1) ←→ (N) KBuzz
- User (1) ←→ (N) Comment
- KBuzz (1) ←→ (N) Comment
- User (N) ←→ (N) KBuzz (Like, Scrap, Bookmark)

**Postman 검증**:
- ERD 구현 후 Postman Collection으로 모든 관계 테스트
- 복잡한 JOIN 쿼리 결과 검증

**Q8: API 설계 원칙은 무엇인가요?**

**A8:** RESTful API 설계 원칙을 따랐습니다:

1. **리소스 기반 URL**: `/users`, `/posts`, `/comments`
2. **HTTP 메서드 활용**: GET, POST, PUT, DELETE
3. **상태 코드**: 200, 201, 400, 401, 404, 500 등 적절한 사용
4. **일관된 응답 형식**: 
```json
{
  "success": true,
  "data": {...},
  "message": "Success"
}
```

**Postman Collection으로 API 일관성 검증**:
- 모든 엔드포인트의 응답 형식 통일성 테스트
- 상태 코드 일관성 검증
- 에러 응답 형식 표준화

**Q9: 보안은 어떻게 구현했나요?**

**A9:** 다층 보안 전략을 적용했습니다:

1. **인증**: JWT + Google OAuth 2.0
2. **인가**: Role-based Access Control (RBAC)
3. **입력 검증**: class-validator로 DTO 검증
4. **SQL Injection 방지**: TypeORM의 Parameterized Query
5. **CORS 설정**: 허용된 도메인만 접근 가능

**Postman 보안 테스트**:
- 인증되지 않은 요청 테스트
- 권한 없는 사용자의 접근 시도 테스트
- SQL Injection 시도 테스트
- XSS 공격 시도 테스트

**Q10: 에러 처리는 어떻게 했나요?**

**A10:** 계층별 에러 처리 전략을 수립했습니다:

1. **Global Exception Filter**: 전역 예외 처리
2. **Custom Exceptions**: 비즈니스 로직별 예외 클래스
3. **Validation Pipe**: 입력 데이터 검증
4. **일관된 에러 응답**: 클라이언트가 이해하기 쉬운 에러 메시지

**Postman 에러 테스트**:
- 각종 에러 상황 시나리오 작성
- 에러 응답 형식 일관성 검증
- 에러 메시지의 명확성 테스트

**Q11: Postman을 활용한 버그 관리 프로세스를 설명해주세요.**

**A11:** 체계적인 버그 관리 프로세스를 구축했습니다:

**1. 자동화된 테스트 실행**:
```bash
# 일일 자동 테스트 실행
newman run postman/K-Mate-API.postman_collection.json \
  -e postman/K-Mate-Environment.postman_environment.json \
  --reporters cli,html \
  --reporter-html-export postman/reports/daily-report-$(date +%Y%m%d).html
```

**2. 버그 발견 프로세스**:
- Postman 테스트 실패 시 자동 알림
- 실패한 테스트 케이스 자동 식별
- 버그 재현을 위한 Postman 요청 재실행
- 서버 로그와 Postman 응답 비교 분석

**3. 버그 추적 및 해결**:
- Postman Collection에 버그 케이스 추가
- 수정 후 동일한 테스트로 검증
- 회귀 테스트를 통한 재발 방지

**실제 사례**:
- **인증 토큰 만료 문제**: Postman 테스트에서 401 에러 발견 → JWT 만료 시간 설정 수정
- **페이지네이션 버그**: Postman으로 다양한 페이지 크기 테스트 → 경계값 처리 로직 수정
- **CORS 설정 오류**: Postman에서 프론트엔드 도메인 테스트 → CORS 정책 수정

**Q12: 향후 개선 계획은 무엇인가요?**

**A12:** 다음과 같은 개선 계획이 있습니다:

1. **성능 최적화**: Redis 캐싱, 쿼리 최적화
2. **모니터링**: APM 도구 도입 (New Relic, DataDog)
3. **로깅**: 구조화된 로깅 시스템 구축
4. **CI/CD**: GitHub Actions를 통한 자동 배포
5. **마이크로서비스**: 서비스 분리 및 API Gateway 도입

**Postman 관련 개선**:
- **Newman CI/CD 통합**: GitHub Actions에 Postman 테스트 자동화
- **성능 테스트**: Postman을 활용한 부하 테스트 시나리오 구축
- **API 버전 관리**: Postman Collection 버전 관리 시스템 구축
- **모니터링 대시보드**: Postman 테스트 결과 실시간 모니터링

### 경험 및 학습 관련 질문

**Q13: 이 프로젝트를 통해 가장 많이 배운 점은 무엇인가요?**

**A13:** 여러 측면에서 많은 것을 배웠습니다:

1. **ORM의 중요성**: 복잡한 SQL을 객체지향적으로 다룰 수 있게 됨
2. **타입 안전성**: TypeScript + TypeORM으로 런타임 오류 대폭 감소
3. **테스트의 중요성**: TDD를 통해 안정적인 코드 작성
4. **아키텍처 설계**: 확장 가능한 모듈 구조의 중요성
5. **Postman의 진가**: 단순한 테스트 도구를 넘어선 개발 생산성 향상 도구

**Postman을 통한 학습**:
- **API 설계 관점**: 클라이언트 관점에서 API 사용성 고려
- **버그 추적 기술**: 체계적인 버그 발견 및 해결 프로세스
- **팀 협업**: Collection 공유를 통한 효율적인 협업 방법

**Q14: 팀 협업은 어떻게 했나요?**

**A14:** 체계적인 협업 프로세스를 구축했습니다:

1. **Git Flow**: feature branch → develop → main
2. **Code Review**: PR을 통한 코드 리뷰 필수
3. **API 문서화**: Swagger로 실시간 API 문서 공유
4. **이슈 관리**: GitHub Issues로 버그 및 기능 요청 관리

**Postman을 통한 협업**:
- **Collection 공유**: 팀 전체가 동일한 API 테스트 환경 사용
- **환경 분리**: 개발자별, 환경별 설정 분리
- **테스트 표준화**: 일관된 API 테스트 방법론 적용
- **실시간 피드백**: API 변경사항 즉시 팀 공유

**Q15: 가장 어려웠던 기술적 도전은 무엇이었나요?**

**A15:** **복잡한 관계형 데이터 모델링과 Postman 테스트 연동**이 가장 어려웠습니다:

**도전**: 사용자-게시글-댓글-좋아요-스크랩-북마크 간의 복잡한 관계를 TypeORM으로 구현하고, Postman으로 모든 관계를 검증

**해결 과정**:
1. **ERD 설계**: 복잡한 관계를 시각적으로 정리
2. **단계적 구현**: 하나씩 엔티티와 관계 구현
3. **Postman 테스트**: 각 관계별 API 테스트 케이스 작성
4. **통합 테스트**: 전체 관계 플로우 테스트

**결과**: 8개 엔티티, 15개 관계를 성공적으로 구현하고 Postman으로 100% 검증

**Q16: 프로덕션 배포 시 고려사항은 무엇인가요?**

**A16:** 다음과 같은 사항들을 고려해야 합니다:

1. **환경 변수**: 민감한 정보는 환경 변수로 관리
2. **데이터베이스**: 마이그레이션 전 백업 필수
3. **로깅**: 구조화된 로깅으로 디버깅 용이성 확보
4. **모니터링**: 성능 및 에러 모니터링 시스템 구축
5. **보안**: HTTPS, 방화벽, 접근 제어 등

**Postman 배포 검증**:
- **프로덕션 환경 테스트**: 배포 후 Postman Collection으로 전체 API 검증
- **성능 테스트**: 프로덕션 환경에서 응답 시간 및 처리량 테스트
- **보안 테스트**: 프로덕션 환경에서 보안 취약점 테스트
- **롤백 계획**: 문제 발생 시 이전 버전으로 롤백 후 Postman 테스트

**Q17: 다른 개발자에게 이 기술 스택을 추천하시나요?**

**A17:** **상황에 따라 다르지만, 다음과 같은 경우에 추천합니다:**

**추천하는 경우**:
- TypeScript를 사용하는 프로젝트
- 복잡한 관계형 데이터를 다루는 애플리케이션
- 팀 개발이 필요한 대규모 프로젝트
- 타입 안전성이 중요한 프로젝트
- **API 품질 보장이 중요한 프로젝트**

**Postman 추천 조건**:
- **팀 협업이 중요한 프로젝트**: Collection 공유로 효율성 향상
- **API 중심 개발**: 프론트엔드와 백엔드 분리 개발
- **품질 보장이 중요한 프로젝트**: 자동화된 테스트로 안정성 확보
- **빠른 개발이 필요한 프로젝트**: 직관적인 테스트로 개발 속도 향상

**추천하지 않는 경우**:
- 간단한 CRUD 애플리케이션
- 빠른 프로토타이핑이 필요한 경우
- 학습 곡선을 피하고 싶은 경우
- **단일 개발자 프로젝트** (Postman의 팀 협업 장점 활용 어려움)

**결론**: NestJS + TypeORM + Postman은 강력하지만 학습 비용이 있으므로, 프로젝트의 복잡도와 팀의 역량을 고려하여 선택하는 것이 중요합니다.

**Q18: Postman 사용 시 주의사항이나 팁이 있나요?**

**A18:** Postman 사용 시 다음과 같은 팁들이 있습니다:

**주의사항**:
1. **환경 변수 관리**: 민감한 정보는 환경 변수로 관리하고 버전 관리에서 제외
2. **Collection 버전 관리**: API 변경 시 Collection도 함께 업데이트
3. **테스트 데이터 관리**: 테스트용 데이터와 실제 데이터 구분
4. **성능 고려**: 대량의 테스트 실행 시 서버 부하 고려

**유용한 팁**:
1. **Pre-request Script 활용**: 동적 토큰 생성, 환경 변수 설정
2. **Test Script 활용**: 응답 검증, 다음 요청을 위한 데이터 저장
3. **Collection Runner**: 여러 요청을 순차적으로 실행
4. **Newman CLI**: 자동화 및 CI/CD 통합
5. **Mock Server**: 프론트엔드 개발을 위한 API 모킹

**실제 활용 예시**:
```javascript
// 환경 변수 자동 설정
pm.environment.set("timestamp", Date.now());
pm.environment.set("random_id", Math.floor(Math.random() * 1000));

// 응답 데이터 검증 및 저장
pm.test("Response has required fields", function () {
    const jsonData = pm.response.json();
    pm.expect(jsonData).to.have.property('id');
    pm.environment.set("created_post_id", jsonData.id);
});
```

**Q19: 이 프로젝트에서 Postman이 가장 효과적이었던 부분은 무엇인가요?**

**A19:** Postman이 가장 효과적이었던 부분들을 소개합니다:

**1. API 개발 초기 단계**:
- 프론트엔드 개발 전 API 동작 확인
- 다양한 요청/응답 시나리오 테스트
- 에러 케이스 빠른 발견 및 수정

**2. 팀 협업**:
- API 명세 실시간 공유
- 프론트엔드 개발자와의 효율적인 소통
- API 변경사항 즉시 전파

**3. 버그 추적**:
- 프로덕션 이슈 재현 및 분석
- 수정 후 즉시 검증
- 회귀 테스트를 통한 재발 방지

**4. 성능 모니터링**:
- API 응답 시간 측정
- 부하 상황에서의 동작 확인
- 성능 회귀 테스트

**실제 효과**:
- **개발 속도**: API 개발 시간 30% 단축
- **버그 감소**: 프로덕션 버그 50% 감소
- **팀 효율성**: API 관련 소통 시간 40% 단축
- **품질 향상**: API 안정성 95% 달성

**Q20: 마지막으로 이 프로젝트를 통해 얻은 가장 큰 성취감은 무엇인가요?**

**A20:** 가장 큰 성취감은 **Postman을 통해 API 품질을 체계적으로 관리할 수 있게 된 것**입니다.

**구체적인 성취**:
1. **완전 자동화된 테스트 환경**: Newman CLI로 100% 자동화된 API 테스트 구축
2. **팀 전체의 API 품질 향상**: Collection 공유로 모든 팀원이 동일한 품질 기준 적용
3. **버그 없는 배포**: Postman 테스트를 통한 프로덕션 배포 시 버그 0건 달성
4. **개발 생산성 혁신**: API 개발 → 테스트 → 배포 전체 프로세스 효율화

**기술적 성장**:
- **API 설계 역량**: 클라이언트 관점에서 API 설계하는 능력 향상
- **테스트 자동화 전문성**: Postman을 활용한 테스트 자동화 마스터
- **팀 리더십**: API 품질 관리 프로세스 구축 및 팀 표준화 주도

**가장 기억에 남는 순간**:
프로덕션 배포 후 Postman Collection을 실행했을 때 모든 테스트가 통과했을 때의 안도감과 성취감이 가장 기억에 남습니다. 이는 단순한 코드 작성을 넘어서 **체계적인 품질 관리 시스템을 구축했다는 것**에 대한 확신을 주었습니다.

이 경험을 통해 **Postman이 단순한 테스트 도구를 넘어서 개발 생산성과 품질 향상의 핵심 도구**임을 확신하게 되었고, 앞으로도 API 중심 개발에서 Postman의 가치를 지속적으로 활용하고 싶습니다.
